<!DOCTYPE html>
<html>
<head>
    <title>html-js</title>
</head>
<body>
    <p align="center">
        <canvas id="mycanvas"></canvas>
    </p>
</body>
<script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script>
<script>
    var sketchProc = function(processingInstance) {
        with (processingInstance) {

            /*XOR function

            inputs  |   output
            0,0     |   0
            1,0     |   1
            0,1     |   1
            1,1     |   0

            This code will try to use a neural network to recognise that when it receives an input of (1,1) the output will be 0.
            */
            var sigmoid = function (x) { //activation function or sigmoid function
                return (1 / (1 + Math.pow(Math.E, -x)));//(Math.round((1 / (1 + Math.pow(Math.E, -x)))*100))/100;
            }
            var sigPrime = function (x) { //derivative of sigmoid
                return (sigmoid(x)*(1 - sigmoid(x)));
            }
            
            var Node = function (sum, result, x, y, w, h) { //node object
                this.sum = sum;
                this.result = result;
                this.x = x;
                this.y = y;
                this.h = h;
                this.w = w;
            };
            Node.prototype.draw = function () { //draw node
                stroke(0, 0, 0);
                fill(255, 255, 255);
                ellipse(this.x, this.y, this.w, this.h);
                fill(0, 0, 0);
                text(this.sum, this.x, this.y);
                text(this.result, this.x, this.y + 10);
            };
            Node.prototype.calculate = function () { //the sum is turned into an activation number
                this.result = sigmoid(this.sum);
            }

            var Synapse = function (value, node0, node1) { //synapse object
                this.value = value;
                this.node0 = node0;
                this.node1 = node1;
            }

            Synapse.prototype.draw = function () { //draw synapse
                stroke(0, 0, 0);
                text(this.value, (this.node0.x + this.node1.x) / 2, (this.node0.y + this.node1.y) / 2);
                strokeWeight(0.1 + Math.abs(this.value));
                line(this.node0.x, this.node0.y, this.node1.x, this.node1.y);
                strokeWeight(1);
            }
            Synapse.prototype.add = function () { //inputs sum of the products of the input nodes and the synapses into the next layer of nodes
                this.node1.sum += (this.value * this.node0.result);
            }
            var trainingData = [{ //XOR function
                "input": [1,1],
                "output": 0
            },
            {
                "input": [0,1],
                "output": 1
            },
            {
                "input": [1,0],
                "output": 1
            },
            {
                "input": [0,0],
                "output": 0
            }];
            var dataSet = 0;
            var gen = 0;
            var inputs = [new Node(trainingData[dataSet].input[0], trainingData[dataSet].input[0], 100, 150, 40, 40), new Node(trainingData[dataSet].input[1], trainingData[dataSet].input[1], 100, 250, 40, 40)]; //input layer
            var hiddens = [new Node(0, 0, 300, 100, 40, 40), new Node(0, 0, 300, 200, 40, 40), new Node(0, 0, 300, 300, 40, 40)]; //hidden layer 1
            var outputs = [new Node(0, 0, 500, 200, 40, 40)]; //output layer
            var iSynapses = [];
            var oSynapses = [];
            var error = 0;
            var deltaOutput = 0;
            var deltaHidden = 0;
            
            size(740, 400); //size of canvas
            frameRate(30); 
            background(255, 255, 200); //draws background colour
            // ---actual coding goes below this line, most functions and variables above this line---

            fill(0, 0, 0);
            stroke(255, 255, 255);
            
            for (var i = 0; i < inputs.length; i++) { 
                for (var j = 0; j < hiddens.length; j++) {
                    iSynapses.push(new Synapse(random(0, 1), inputs[i], hiddens[j]));
                }
            }
            for (var i = 0; i < hiddens.length; i++) {
                for (var j = 0; j < outputs.length; j++) {
                    oSynapses.push(new Synapse(random(0, 1), hiddens[i], outputs[j]));
                }
            }
            
            for (var i = 0; i < iSynapses.length; i++) {
                iSynapses[i].add();
            }

            for (var i = 0; i < hiddens.length; i++) {
                hiddens[i].calculate();
            }

            for (var i = 0; i < oSynapses.length; i++) {
                oSynapses[i].add();
            }
            outputs[0].calculate();
            error = trainingData[0].output - outputs[0].result;
            deltaOutput = sigPrime(outputs[0].sum)*(error);
            //console.log(error);
            
            /*
            for (var i = 0; i < outputs.length; i++) {
                outputs[i].draw();
            }*/
            console.log(iSynapses);
            console.log(oSynapses);
            console.log(hiddens);
            console.log(outputs);

            
            
            draw = function () {
                background(255, 255, 200);
                for (var i = 0; i < iSynapses.length; i++) {
                    iSynapses[i].draw();
                }
                for (var i = 0; i < oSynapses.length; i++) {
                    oSynapses[i].draw();
                }

                for (var i = 0; i < inputs.length; i++) {
                    inputs[i].draw();
                }
                for (var i = 0; i < hiddens.length; i++) {
                    hiddens[i].draw();
                }
                for (var i = 0; i < outputs.length; i++) {
                    outputs[i].draw();
                }
            }
            mouseClicked = function () {
                gen++;
                println("generation " + gen);
                var k = 0;
                for (var j = 0; j < inputs.length; j++) {
                    for (var i = 0; i < hiddens.length; i++) {
                        var deltaWeight = (deltaOutput / oSynapses[i].value) * sigPrime(oSynapses[i].node0.sum);
                        deltaWeight = deltaWeight * trainingData[dataSet].input[j];
                        iSynapses[k].value += deltaWeight;
                        k++;
                    }
                }
                for (var i = 0; i < oSynapses.length; i++) {
                    var deltaWeight = deltaOutput / oSynapses[i].node0.result;
                    oSynapses[i].value += deltaWeight;
                    //console.log(deltaWeight);
                }
                for (var i = 0; i < hiddens.length; i++) {
                    hiddens[i].sum = 0;
                    hiddens[i].result = 0;
                }
                for (var i = 0; i < outputs.length; i++) {
                    outputs[i].sum = 0;
                    outputs[i].result = 0;
                }
                for (var i = 0; i < iSynapses.length; i++) {
                    iSynapses[i].add();
                }

                for (var i = 0; i < hiddens.length; i++) {
                    hiddens[i].calculate();
                }

                for (var i = 0; i < oSynapses.length; i++) {
                    oSynapses[i].add();
                }
                outputs[0].calculate();
                error = trainingData[dataSet].output - outputs[0].result;
                deltaOutput = sigPrime(outputs[0].sum) * (error);
            }

            
            
            
        }
    };
    var canvas = document.getElementById("mycanvas");

    var processingInstance = new Processing(canvas, sketchProc);

</script>
</html>
